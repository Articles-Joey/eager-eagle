/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Building 1-transformed.glb 
*/

import { useEffect, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useBox } from '@react-three/cannon'
import * as THREE from 'three'

export function ModelBuildingOne(props) {
  const { noPhysics } = props
  const { nodes, materials } = useGLTF('models/Building 1-transformed.glb')

  const { args, offset } = useMemo(() => {
    const geometry = nodes.skyscraper.geometry
    geometry.computeBoundingBox()
    const size = new THREE.Vector3()
    geometry.boundingBox.getSize(size)
    const center = new THREE.Vector3()
    geometry.boundingBox.getCenter(center)
    return { args: [size.x, size.y, size.z], offset: center }
  }, [nodes])

  const baseHeight = useMemo(() => Math.random() * 3, [])

  if (noPhysics) {
    // Render without physics
    return (
      <group>
        <group dispose={null}>
          <group position={[-offset.x, -offset.y, -offset.z]}>
            <mesh geometry={nodes.skyscraper.geometry} material={materials.None} />
          </group>
        </group>
        {/* <mesh position={[props.position?.[0] || 0, (props.position?.[1] || 0) - (args[1] / 2) - (baseHeight / 2), props.position?.[2] || 0]}>
          <boxGeometry args={[args[0], baseHeight, args[2]]} />
          <meshStandardMaterial color="gray" />
        </mesh> */}
      </group>
    )
  }

  // Physics-enabled version
  const [ref, api] = useBox(() => ({
    mass: 0,
    type: 'Kinematic',
    args: args,
    position: props.position || [0, 0, 0],
    collisionFilterGroup: 2,
    ...props
  }))

  const [baseRef, baseApi] = useBox(() => ({
    mass: 0,
    type: 'Kinematic',
    args: [args[0], baseHeight, args[2]],
    position: [props.position[0], props.position[1] - (args[1] / 2) - (baseHeight / 2), props.position[2]],
    collisionFilterGroup: 2,
    ...props
  }))

  useEffect(() => {
    if (props.position) {
      api.position.set(props.position[0], props.position[1] + baseHeight, props.position[2])
      baseApi.position.set(props.position[0], props.position[1] + (baseHeight / 2) - (args[1] / 2), props.position[2])
    }
  }, [props.position, api, baseApi, baseHeight, args])

  return (
    <group>

      <group ref={ref} dispose={null}>
        <group position={[-offset.x, -offset.y, -offset.z]}>
          <mesh geometry={nodes.skyscraper.geometry} material={materials.None} />
        </group>
      </group>

      {/* <mesh ref={baseRef}>
        <boxGeometry args={[args[0], baseHeight, args[2]]} />
        <meshStandardMaterial color="gray" />
      </mesh> */}

    </group>
  )
}

useGLTF.preload('models/Building 1-transformed.glb')